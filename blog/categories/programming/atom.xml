<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Automatic Coding]]></title>
  <link href="http://rdallasgray.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rdallasgray.github.io/"/>
  <updated>2015-08-04T09:54:10+01:00</updated>
  <id>http://rdallasgray.github.io/</id>
  <author>
    <name><![CDATA[Robert Dallas Gray]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lessons in developing with Vagrant]]></title>
    <link href="http://rdallasgray.github.io/blog/2015/08/03/lessons-in-developing-with-vagrant/"/>
    <updated>2015-08-03T09:51:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2015/08/03/lessons-in-developing-with-vagrant</id>
    <content type="html"><![CDATA[<p>At work, we use <a href="http://vagrantup.com">Vagrant</a> to create and manage development environments. Once you've experienced working like this, you probably won't want to work the 'old' way ever again (I've begun to transition my personal projects to using Vagrant now, too). Having each project come with its own complete, isolated environment allows any developer to pick it up and work on it immediately; it also makes deployment a part of the development process, as each provisioning run of the Vagrant VM is effectively a miniature deployment in itself. When the project is to be deployed to a staging or production environment, you can use much the same tried and tested processes to do so (we use <a href="http://www.chef.io">Chef</a>).</p>

<p>From what I'm hearing and reading, more and more developers are working like this, but it's still not a particularly well-understood way of doing things. The usual way it's done is that your editor and tools live on your host machine, you interact with the project code on the guest machine using a shared folder, and you run tests and other development processes on the guest machine via ssh.</p>

<p>Sounds pretty straightforward, but there are some subtle problems. One is filesystem events, which don't work as they normally would.</p>

<h2>Watching the filesystem</h2>

<p>In most modern operating systems, there's some kind of mechanism for a process to receive notifications when files change. In Linux it's <a href="http://man7.org/linux/man-pages/man7/inotify.7.html">inotify</a>, for example. These mechanisms allow processes to watch a set of files for changes without <em>polling</em> the filesystem (i.e. repeatedly checking the modification times of the watched files). Because they work natively, and without polling, they're very fast.</p>

<p>In the standard Vagrant development setup, though, you're making changes to the files on the <em>host</em> machine, but running the watching processes in the <em>guest</em> machine. And unfortunately that means that mechanisms like <code>inotify</code> don't work.</p>

<p>If you use <a href="https://github.com/guard/guard">Guard</a>, for example, to run tests in a Ruby app when files change, it uses <a href="https://github.com/guard/listen">Listen</a> to watch the filesystem. Listen ships with adaptors for many different notification systems, including a fallback polling adaptor. Until quite recently, the only way to use Guard inside a Vagrant VM was to use the polling adaptor -- which is very slow, and very resource-intensive. Polling the files in a decent-sized Rails app at an interval of 1 second will most likely pin the CPU of the guest machine; also, in my experience it just wasn't reliable (changes often wouldn't seem to be noticed, or would be noticed late).</p>

<p>If you're using something like <a href="http://github.com/guard/guard-rspec">guard-rspec</a> to do continuous TDD, for instance, then having to repeatedly nudge the filesystem to pick up changes, and wait several seconds for them to be picked up, becomes, well, painful. There's a way round this, though: Listen and Guard provide a way to listen to filesystem events in one machine and forward the events to another machine over the network. I won't describe this in detail, because <a href="http://jamie.ideasasylum.com/2014/02/efficiently-using-guard-vagrant-rails-development/">it's been done elsewhere</a>.</p>

<p>There are a couple of niggling inconveniences with this solution, though. Firstly, it's just cumbersome: You need to start a <code>listen</code> process on your host machine, then start a <code>guard</code> process on your guest machine, and then remember to shut them both down when you're done. In a traditional setup you just run <code>guard</code> and away you go.</p>

<p>Secondly, the <code>guard</code> process needs to know the full path to the watched directory <em>on the host machine</em>, which means it's hard to make the setup portable (it's a near certainty that the path will be different for every developer on the project).</p>

<h3>vagrant-triggers</h3>

<p>Enter <a href="https://github.com/emyl/vagrant-triggers">vagrant-triggers</a>, which lets you do arbitrary stuff around the lifecycle events of a Vagrant VM. We can use this to start and stop <code>listen</code> on the host machine for us, which solves issue one. And we can set up some environment variables inside the guest machine to solve problem two. Let's do that first.</p>

<p>```ruby</p>

<h1>In Vagrantfile:</h1>

<p>LISTEN_PORT = 4000
config.vm.network :forwarded_port, guest: LISTEN_PORT, host: LISTEN_PORT
config.vm.provision :shell, inline: &lt;<-END
echo "export HOST_ROOT=#{File.dirname(__FILE__)}" > /etc/profile.d/host_root.sh
echo "export LISTEN_PORT=#{LISTEN_PORT}" > /etc/profile.d/listen_port.sh
END
```</p>

<p>That creates the environment variables <code>HOST_ROOT</code> and <code>LISTEN_PORT</code> in the guest machine, and forwards <code>LISTEN_PORT</code> to the guest. Next we create a couple of simple functions in the Vagrantfile:</p>

<p><code>``ruby
def stop_listen_script
  listen_exe =</code>which listen<code>.chomp
  ps =</code>ps aux | grep '#{listen_exe}'`</p>

<pre><code>.match(/\w*\s+(\d+)\s+.*127\.0\.0\.1:#{LISTEN_PORT}/)
</code></pre>

<p>  if (pid = (ps &amp;&amp; ps[1]))</p>

<pre><code>"kill #{pid}"
</code></pre>

<p>  else</p>

<pre><code>"true"
</code></pre>

<p>  end
end</p>

<p>def start_listen_script
  "listen -f 127.0.0.1:#{LISTEN_PORT} > /dev/null 2>&amp;1 &amp;"
end
```</p>

<p><code>start_listen_script</code> starts <code>listen</code> and forwards change notifications to <code>LISTEN_PORT</code>; because we've forwarded that port to the guest machine, the guest machine will receive the notifications.</p>

<p><code>stop_listen_script</code> checks for a running process in the host machine which matches the <code>listen</code> executable and arguments, and if it finds one, kills it. We need to do this so that Vagrant can run its lifecycle operations correctly, and so we don't end up with lots of orphan <code>listen</code> processes.</p>

<p>Now we're almost ready to create some triggers, but we need to make some additional gems available to Vagrant. Run the following in your host machine:</p>

<p><code>ruby
vagrant plugin install celluloid-io &amp;&amp; vagrant plugin install thor
</code></p>

<p><a href="https://github.com/celluloid/celluloid-io">celluloid-io</a> and <a href="https://github.com/erikhuda/thor">thor</a> are necessary for <code>listen</code> to work correctly when started as part of Vagrant's lifecycle (interesting to note here that <code>vagrant plugin install</code> is just <code>gem install</code> in disguise -- it can make arbitrary gems available to Vagrant).</p>

<p>Next we need to make sure <code>listen</code> is available on our host machine:</p>

<p><code>ruby
gem install listen
</code></p>

<p>And finally install <code>vagrant-triggers</code>:</p>

<p><code>ruby
vagrant plugin install vagrant-triggers
</code></p>

<p>Now we can create the following triggers in our Vagrantfile:</p>

<p>```ruby</p>

<h1>Stop listen whenever we shut down or re-forward ports (a running listen</h1>

<h1>will prevent port forwarding).</h1>

<p>[:up, :resume, :suspend, :halt, :destroy, :reload].each do |cmd|
  config.trigger.before cmd do</p>

<pre><code>run stop_listen_script
</code></pre>

<p>  end
end</p>

<h1>Start listen when we start the machine</h1>

<p>[:up, :resume, :reload].each do |cmd|
  config.trigger.after cmd do</p>

<pre><code>run start_listen_script
</code></pre>

<p>  end
end
```</p>

<p>That will start <code>listen</code> on the host when we bring our VM up, and stop <code>listen</code> when we take it down or cycle it. All we need now is a way to properly run <code>guard</code> inside the guest machine, picking up the correct watch directory and ports. We can do that in our project's Rakefile:</p>

<p>```ruby
namespace :guard do
  desc "Start guard, listening for changes on a given port at the default gateway"
  task :remote do</p>

<pre><code>cmd = "guard --clear -o '10.0.2.2:#{ENV['LISTEN_PORT']}' -w '#{ENV['HOST_ROOT']}'"
system(cmd)
</code></pre>

<p>  end
end
```</p>

<p>That works thanks to the environment variables we pushed into the guest machine earlier. Note that I hardcode the IPs to <code>127.0.0.1</code> on the host and <code>10.0.2.2</code> on the guest, because they're the defaults -- you can change them, or make them configurable if you want. Now we can run Guard in the guest machine like so:</p>

<p><code>ruby
bundle exec rake guard:remote
</code></p>

<p>Much better.</p>

<h3>The front end</h3>

<p>We don't only develop Rails apps though. We also have a burgeoning front-end estate, and for that we use <a href="http://npmjs.com">npm</a>, <a href="http://browserify.org">Browserify</a> and <a href="http://karma-runner.github.io">Karma</a>, among other things. These all present their own issues. Firstly, as far as file-watching goes, we're stuck with polling on the front end. To my knowledge, none of the JS filewatching solutions provide anything out-of-the-box like Listen's network forwarding, so if you're using <a href="https://github.com/substack/watchify">Watchify</a> to run incremental Browserify builds,
make sure to pass the <code>poll</code> option (see the Watchify docs). Continuous testing with Karma defaults to polling automatically, as does live reloading with <a href="http://www.browsersync.io">Browsersync</a>. There is one big headache remaining though.</p>

<h2>npm</h2>

<p>When we started using npm and Browserify to build our front-end projects, we were, ah, <em>dismayed</em> by how long it took to run a complete <code>npm install</code>. The turnaround could be minutes -- sometimes double figures of minutes -- which made any change in dependencies agonising. To boot, it quite often hung or failed entirely. We entertained a few potential solutions (running a local caching server, adjusting the npm cache settings e.g.) before we noticed something odd.</p>

<h3>nfs</h3>

<p>A new front-end developer we'd taken on wasn't using Vagrant, and had resisted switching to it. It turned out that his resistance was owing to how long it took for <code>npm install</code> runs to complete. Because <em>on his host machine</em>, they were <em>fast</em>. Where our runs would take 7 minutes, his took <em>40 seconds</em>. So it was immediately apparent that the problem wasn't just npm -- it was Vagrant, too (or to be more accurate, VirtualBox).</p>

<p>We did a bit of research into what the problem could be, and it occurred to me that some time ago when I'd been trying to get Guard to work, I'd read about using <a href="https://www.freebsd.org/doc/handbook/network-nfs.html">nfs</a> rather than the default VirtualBox filesystem to share folders between host and guest. Using nfs had caused more problems than it seemed to solve, so I gave up, but I recalled during that research I'd read some Vagrant users suggesting that the VirtualBox filesystem could be slow for certain operations. So we tried nfs again. Bam: 40-second npm runs.</p>

<p>It turns out that VirtualBox Shared Folders (<code>vboxsf</code>), the default filesystem when using VirtualBox with Vagrant, is <em>extremely</em> slow for almost all operations (see e.g. <a href="http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines">http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines</a>). With a tool like npm, which in the course of an install reads and writes thousands of files, this is disastrous. We'd never noticed the issue in our Rails apps, using Bundler, but npm's architecture (which installs a full copy of every subdependency in the tree), combined with the Javascript fashion for lots of very small modules, was enough to bring the deficiencies of <code>vboxsf</code> to a very noticeable light.</p>

<p>Just switching to nfs, though, wasn't enough to solve all our problems. When I'd used it before, I'd had issues with unwanted caching (files not appearing to change in the guest machine when changed on the host). So we had to do a bit more research to figure out how to tweak the nfs setup to suit. This is what we ended up with:</p>

<p>```ruby</p>

<h1>VirtualBox needs this to use nfs</h1>

<p>config.vm.network "private_network", type: "dhcp"
config.vm.synced_folder ".", nfs: true,
  mount_options: %w{nolock,vers=3,udp,noatime,actimeo=1}
```</p>

<p>Note the <code>mount_options</code> parameter: this passes the given array as arguments to the command Vagrant uses to start nfs. Here's what they do:</p>

<ul>
<li><code>nolock</code> prevents the guest and host filesystems from sharing file locking information. It's a workaround to allow the use of older nfs servers -- we found it necessary to enable sharing between our Ubuntu 12 guests and OS X hosts.</li>
<li><code>vers=3</code> forces the version of nfs server to use. Again we found this necessary, but you may not.</li>
<li><code>udp</code> forces the use of udp rather than tcp, which we found gave a performance boost.</li>
<li><code>noatime</code> prevents the modification of the last-updated timestamp on files, which again gives a performance boost.</li>
<li><code>actimeo=1</code> sets the caching timeout to one second, which fixed the issues we were having with unwanted caching.</li>
</ul>


<p>When the Vagrant machine is started or cycled, you may be asked for your password, because Vagrant has to modify the <code>/etc/exports</code> file on your host system to enable the share. Otherwise, this setup works well for us -- we get fast npm runs and file watches that don't completely pin the guest cpu.</p>

<h2>Finally</h2>

<p>This way of doing dev work is still fairly immature, and we've had to find our own solutions to the problems it poses. There are still things that don't work -- something like <a href="https://github.com/dgutov/robe">Robe</a> for example, which can run a Ruby process and use it to provide code completion and navigation, has so far been too difficult to get working across the host/guest boundary.</p>

<p>That's a nice-to-have though; the benefits of working this way make it more than worthwhile to work on solutions to the problems.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a (fairly) sane dev environment in Windows]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/09/28/building-a-fairly-sane-dev-environment-in-windows/"/>
    <updated>2013-09-28T19:42:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/09/28/building-a-fairly-sane-dev-environment-in-windows</id>
    <content type="html"><![CDATA[<p>I recently left a job that mandated Windows as a development
environment. Well, that's not strictly true -- they were happy enough
for me to use Linux in a VM, but that was ultimately more trouble than
it was worth.</p>

<p>I've had to dip into Windows before (having worked a job where the
server-side code was .Net), but I've never had to use it as a primary
dev environment. Long story short: it is <em>extremely</em> painful to use
Windows for modern web development, or any kind of development which
is not explicitly <em>for</em> Windows.</p>

<p>Here is a statement of the main problems, and the measures which can
get you at least close to a solution.</p>

<h2>Git</h2>

<p>An odd one to start with perhaps, but it has a significant impact on
the rest of the setup. There are two ways you can get a usable Git
setup working on Windows: one is to use
<a href="http://www.cygwin.com">Cygwin</a>, of which more below, and one is
<a href="http://msysgit.github.io">Git for Windows</a>, otherwise known as
MSYS-Git. You can download a lightweight version of
MSYS-Git as <a href="http://git-scm.com/downloads">Git Bash</a> -- which, you
shouldn't be surprised to hear, comes with an implementation of Bash
-- but I'm going to advise getting the
<a href="http://code.google.com/p/msysgit/downloads/list?q=net+installer">full installer</a>. It
should become clear why.</p>

<p>MSYS-Git is quite slow; apparently the version that you can use with
Cygwin is faster, but Cygwin was too much of an overhead for my purposes.</p>

<h2>The command line</h2>

<p>Where to begin. The Windows command line is a  disaster, unless
all you need to do is change directories and open files. No grep. No
vi. No sed. The knock-on effects, on editors and other tools which rely
on these utilities, are not fun. I'd been recommended
<a href="http://code.google.com/p/clink/">clink</a>, which offers Bash-like
completion, but it's still ... the Windows command line.</p>

<p>The options, if you want Bash or something like it, are
<a href="http://www.cygwin.com">Cygwin</a>, effectively a complete replacement
for the Windows command system,
<a href="https://github.com/bmatzelle/gow/wiki">GoW (Gnu on Windows)</a>, a
lighter-weight port of a set of Gnu utilities, or
<a href="http://www.mingw.org/wiki/MSYS">MSYS</a>, a package similar to GoW,
intended for compiling Gnu utilities on Windows. An outside choice is
<a href="http://www.emacswiki.org/emacs/CategoryEshell">Eshell</a> if you're an
Emacs user; I tried it, but found it didn't fit well with my workflow.</p>

<p>Cygwin is a very comprehensive solution: it presumes you're basically
going to <em>exist</em> within it, which really didn't work for me. GoW was
nice, but didn't play well with the Git-integrated Bash (see above),
and neither did a separate install of MSYS. For these reasons, I
suggest installing the complete MSYS-Git environment I mentioned
above: you get Git, Bash and a decent subset of the Gnu utilities, all well-integrated.</p>

<h2>A terminal emulator</h2>

<p>That this is not a solved problem should give you some idea of The
State of Things. There are two contenders, neither of which really represents an
resounding victory:
<a href="http://code.google.com/p/conemu-maximus5/">ConEmu</a> and
<a href="http://sourceforge.net/projects/console/files/">Console2</a>. (Incidentally,
are you noticing how much of this stuff is on Google Code? And
<em>SourceForge</em> for heaven's sake? The mind boggles). ConEmu is highly
configurable. I do not need my terminal emulator to be highly
configurable. Console2 is marginally easier to use, but pug ugly. I
went for Console2.</p>

<h2>Package management</h2>

<p>The only real game in town here is
<a href="http://chocolatey.org">Chocolatey</a>. Like most community projects in
the Windows world, it's undermaintained and generally a bit thin, but at least
it's there. (And no disrespect to the maintainers here: it's numbers
I'm complaining about, not individual effort). Installs largely work;
uninstalls or upgrades often don't. But until
<a href="https://github.com/nddrylliog/winbrew">Winbrew</a> is reliable, there we
are. I managed to get <a href="http://chocolatey.org/packages/ack">ack</a>
installed via Chocolatey, so two cheers for it, at least; all the
packages mentioned above are available too.</p>

<h2>Runtime/language version managers</h2>

<p>I'm talking about the likes of
<a href="https://github.com/creationix/nvm">nvm</a> and
<a href="https://github.com/postmodern/chruby">chruby</a> here. I used
<a href="https://github.com/marcelklehr/nodist">Nodist</a> (because it was
available on Chocolatey and <a href="https://github.com/hakobera/nvmw">nvmw</a>
wasn't); there's also <a href="https://github.com/vertiginous/pik">pik</a> for
Ruby, but I couldn't get it working.</p>

<h2>Type</h2>

<p>Call me frivolous, but I have a background in typography and I <em>cannot
stand</em> the look of type on Windows. The fault lies with the
anti-aliasing, which only works in the vertical plane; type looks
spindly and horrible, no matter how you set it up. If you're used to
modern-looking type, as rendered on OS X or Ubuntu, and you have any
sort of sensitivity to these things, you just can't live with it.</p>

<p>It's not a total solution, but
<a href="https://code.google.com/p/mactype/">MacType</a> saved me clawing my eyes
out, at least.</p>

<h2>In summary</h2>

<p>Attempting web development on Windows feels like being thrown back in
time five years or so. I've touched on the main pain points, but I
can't even remember how many, many times I had to ransack Stack
Overflow to find out why such-and-such a gem wouldn't work properly,
or dig about in the awful Registry. How many times I restarted the
machine to be told that Windows had decided to install 127
updates. How long and often I watched the spinny blue circle while a bleedin'
<em>Explorer window</em> opened. Ubuntu, <em>in a VM</em>, was considerably faster
and more usable in every way.</p>

<p>The larger problem is that the whole experience of working on Windows
is so rotten that <em>nobody wants to fix this stuff</em>. Plenty of GitHub
issues I followed, on large, respectable repos, were
unresolved. 'Windows,' said the maintainers. Won't fix. Closed.</p>

<p>I really can't blame them, and similarly, I can see why the
whole open-source movement is so backward on the Windows platform;
hardly anyone's there, and community is what keeps all this going.
I hope, for the sake of the people who have to use it, that it gets
better. I won't be hanging around to see, though.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some technical podcasts I listen to]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/09/27/some-technical-podcasts-i-listen-to/"/>
    <updated>2013-09-27T20:57:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/09/27/some-technical-podcasts-i-listen-to</id>
    <content type="html"><![CDATA[<p>Been a while. Here's a short one on some of the stuff I listen to when
I have the time. It's intended primarily to solicit responses of the
'You like that? Then you'll like this!' variety -- I need more
material.</p>

<p>So, top five.</p>

<h2>Ruby Rogues</h2>

<p><a href="http://rubyrogues.com">link</a></p>

<p>An indisputable number one. Doesn't matter whether you're a Rubyist --
you'll get something from this. It's very well produced, the regulars
are well-practised, and the guests are frequently stellar (Kent Beck,
e.g.). Despite (or perhaps because of) the Ruby focus, the topics tend
to be relevant to software engineering in general, especially the reading list
episodes: Patterns of Application Architecture, Smalltalk Best
Practice Patterns, Growing Object Oriented Software ... it's the
canon, not just the Ruby stuff. Highly recommended.</p>

<h2>The Changelog</h2>

<p><a href="http://thechangelog.com">link</a></p>

<p>An overview of what's happening in open source. Very on the
pulse. Great guests, good production values and educated hosts
(although, in the nicest possible way, Adam Stacoviak would benefit
the show by doing more listening and less talking).</p>

<h2>Javascript Jabber</h2>

<p><a href="http://javascriptjabber.com">link</a></p>

<p>I'm paying less attention to Javascript these days, but I still
subscribe to and enjoy this podcast. Same stable as Ruby Rogues, and
same presenter (the very personable Charles Max Wood); similarly high
production values, too. Good guests and high-level chat.</p>

<h2>Mostly Erlang</h2>

<p><a href="http://mostlyerlang.com">link</a></p>

<p>It's interesting to get a bit out of your comfort zone. Erlang people
talk about different stuff. The show is patterned after the Ruby
Rogues/Javascript Jabber format, but the nature of the community is so
different that it's not really comparable; production values are
lower, but the guests, and the general tone, are much more oriented
toward serious systems engineering, which makes a refreshing listen,
for me.</p>

<h2>Pragmatic Podcasts</h2>

<p><a href="http://pragprog.com/podcasts">link</a></p>

<p>Somewhat few and far between (it's hard to tell if they're even still
going), these are what you'd expect from the PragProg stable: serious,
somewhat conservative, but very valuable. At their best they afford a
very high-level view of the practice of software development.</p>

<p>Honourable mentions: <a href="http://nodeup.com">NodeUp</a>, <a href="http://episodes.gitminutes.com">Git Minutes</a>, <a href="http://foodfightshow.org">Food Fight</a>.</p>

<p>Don't even talk to me about the Dev Show.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's wrong with JavaScript]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/06/09/whats-wrong-with-javascript/"/>
    <updated>2013-06-09T14:11:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/06/09/whats-wrong-with-javascript</id>
    <content type="html"><![CDATA[<p><em>(Updated 2013-06-10 with some corrections and fine-tunings)</em></p>

<p>So from my <a href="/blog/2013/05/11/mod-lang/">last post</a> you might guess I'm
an advocate for JavaScript. Well, I have more time for the language
than many Rubyists seem to: it has a nicely compact API and, once
you've learned to avoid the potholes, it's an easy language to get
things done in. CoffeeScript makes it considerably less painful to
read and write, and the Node ecosystem is generating some very useful
toolsets and ways of working.</p>

<p>There are, though, some significant pain-points involved in writing
non-trivial programs in JavaScript. Some of them are well-covered in
the literature already, but there are some that seem not to be. I'm
interested to gauge the extent to which others have come up against some
of these, so here's my take on what's <em>really</em> wrong with JavaScript.</p>

<h2>The obvious stuff</h2>

<p>I'm not going to dwell on any of this, because it's <a href="http://javascript.crockford.com/survey.html">well-trodden territory</a>,
but to get it out of the way: the scoping is wacky (and the <code>var</code> trap
is a disaster); the comparison operators (<code>==</code> vs <code>===</code>) are a kludge;
and the treatment of the <code>this</code> keyword is tiresome. There are many
more dark corners (see, for instance, <a href="http://www.youtube.com/watch?v=kXEgk1Hdze0">Gary Bernhardt's WAT</a>), but all
of these issues can be worked around more or less easily (and in fact
CoffeeScript largely does so). There are other issues with the
language that I'd argue are harder to deal with -- in some cases,
practically impossible.</p>

<h2>What is an object?</h2>

<p>So, famously, JavaScript is not a class-based language. It uses
prototypal inheritance. This is a somewhat simpler type of
object-oriented language design, whereby object instances inherit both data and
behaviour from other object instances. It can work quite well (it's a
very memory-efficient system if used properly), and it can to some
extent be used to mimic class-based inheritance if that's what you
want. The problem with JavaScript, though, is what it uses for
'objects'.</p>

<p>In JavaScript, an 'object' is effectively just a key--value structure. It is what
in other languages is called a hash, a map or a dictionary. It looks like this:</p>

<p>```javascript
var obj = {</p>

<pre><code>foo: "I'm a property!",
bar: function() {
    return "And I'm a method!"
},
baz: function() {
    return this.bar();
}
</code></pre>

<p>}
```</p>

<p>We could either use this object as-is, in which case it's what in a
class-based language we'd call a Singleton, or we can use it as the
prototype for another object instance (there are several ways to
accomplish this -- they're covered elsewhere, so I won't expand).</p>

<p>As you can see, there's no distinction between a 'method' (a member of
the object which is a function) and a 'property'. Everything is just a
value indexed on a key. Nice and simple, but take a CoffeeScript
instance method like this one:</p>

<p><code>coffeescript
thing: -&gt;
  @thing ?= new Thing
</code></p>

<p>This looks pretty and idiomatic: it's an accessor method which
assigns <code>@thing</code> if it doesn't already exist, then returns it.
See the problem?</p>

<p>CoffeeScript's syntax is helping to hide the fact that we've bound the
instance variable to the same key as the method (<code>this.thing</code>). I hope
this seems obvious to you, and that you're wondering how anyone could
be so stupid as to do such a thing. I am here to tell you that this is
something that a busy developer will do (especially one familiar with
Ruby), and that it will then manifest a very subtle bug which does not
immediately show up in unit tests. I will leave you to speculate as to
how I can be so sure about this.</p>

<p>Now, sure, we could be sensible and create <code>setThing</code> and <code>getThing</code>
methods, but, you know, we're not writing Java. We're in a highly
dynamic language. We want nice things. Or, we could create setters and
getters using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get">new ES5 syntax</a>
-- but that's not available everywhere (pre-IE9, for instance), and, I
would argue, is too unwieldy to apply as a rule.</p>

<p>So what we're left with is doing something like:</p>

<p><code>coffeescript
thing: -&gt;
  @_thing ?= new Thing
</code></p>

<p>Which is ... irritating. But if we want this kind of method syntax,
that's what we have to do, and we have to be vigilant that we don't
introduce mistakes like the above, because no lint tool will catch them.</p>

<p>It's tempting to presume that this is a 'feature' of prototypal
inheritance; it's not. The two next best-known prototypal languages,
<a href="http://selflanguage.org/_static/tutorial/Language/ObjectsAndSlots/ObjectsAndSlots.html">Self</a> and <a href="http://www.lua.org/pil/16.html#ObjectSec">Lua</a>, distinguish properties and methods just fine.</p>

<h2>Everything is an object</h2>

<p>And that's a good thing, right?</p>

<p>Well, first, it's not really true of JavaScript: you need to <a href="http://blogs.adobe.com/webplatform/2012/08/27/javascript-types/">'box'</a>
primitives like numbers to get them to behave like objects, but fair
enough, many languages do something similar. Second, and more
importantly, see above as regards what objects in JavaScript <em>actually
are</em>. What we're really saying is 'everything is a key--value structure'. Is that
a good thing?</p>

<p>No. It isn't. Imagine another hypothetical CoffeeScript method:</p>

<p>```coffeescript
copyObject: (inputObject) ->
  copy = []
  for key, val of inputObject</p>

<pre><code>copy[key] = val
</code></pre>

<p>```</p>

<p>Spot the deliberate mistake? Busy developer has initialised <code>copy</code> to
an array rather than an object. The really bad news? <em>This method will
work almost as if it were correct</em>. We can get every key of
<code>inputObject</code> on <code>copy</code> correctly, because an array, in JavaScript, is
an object, and therefore <em>is just a key--value structure</em>. We can set
(pretty much) any key on it we like, and get it back intact. But
again, subtle bugs abound; arrays are not intended to be used like
this, and things will go wrong if, for example, you start trying to
iterate over <code>copy</code>'s properties, expecting it to be a 'real' object.</p>

<p>Ouch.</p>

<h2>Nothing is an object</h2>

<p>Try this, in a CoffeeScript class:</p>

<p>```coffeescript
bindClick: ->
  $("#clickable").on "click", @onClick</p>

<p>respondToClick: ->
  window.alert "clicked!"</p>

<p>onClick: ->
  @respondToClick()
```</p>

<p>So presuming <code>bindClick</code> has been called, what happens when we click
on <code>"#clickable"</code>?</p>

<p><code>respondtoClick</code> will never be called, and you'll almost certainly get
an exception. Remember, there are no methods in Javascript, only
functions. We bound the function <code>this.onClick</code> to the click event;
that function has no idea that it's also a method. Why should a value
in a key--value structure know which structure it belongs to? In the
context of the function <code>this.onClick</code>, <code>this</code> is the function itself
or, sometimes, the <code>window</code> object. Neither of these has a
<code>respondToClick</code> method, so we get an exception.</p>

<p>In short, we can call any function in scope, from anywhere, regardless of
whether it's part of an 'object'; and attaching a function to an object as
a method only binds <code>this</code> correctly <em>when the function is called in
the context of its parent object</em>.</p>

<p>The correct way to do the above is of course:</p>

<p><code>coffeescript
bindClick: -&gt;
  $("#clickable").on "click", =&gt; @respondToClick()
</code></p>

<p>We pass an anonymous function to <code>.on</code>, explicitly binding <code>this</code> to
our current context using CoffeeScript's <code>=&gt;</code> operator.</p>

<h2>_missing</h2>

<p>All of the above can be worked around or avoided; at
present, one very important thing can't be. JavaScript has no
equivalent to <a href="http://ruby-doc.org/core-2.0/BasicObject.html#method-i-method_missing">Ruby's <code>method_missing</code></a>, <a href="http://c2.com/cgi/wiki?DoesNotUnderstand">Smalltalk's
<code>doesNotUnderstand</code></a>, <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html">Objective-C's <code>forwardInvocation</code></a>, <a href="http://php.net/manual/en/language.oop5.overloading.php">PHP's <code>__call</code></a>,
etcetera. You can't catch a call to an undefined method in JavaScript
and then do something with it. This is, again, to do with the fact
that there's nothing to distinguish 'properties' from 'methods' in
JavaScript; plenty of 'properties' won't be callable as functions, but
that doesn't necessarily mean they <em>should be</em>.</p>

<p>It's important to be able to do this in traditional object-oriented
design; we need it to do proper <a href="http://en.wikipedia.org/wiki/Delegation_(programming">delegation</a>, for example. It's also a
tremendously convenient feature if you want to do metaprogramming
(e.g. adding properties or methods to an object dynamically at
runtime). There are two ways to sort-of do it right now: one is
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/noSuchMethod">Mozilla's <code>__noSuchMethod__</code></a>, which is only supported in SpiderMonkey
and likely to be deprecated; the other is the 'official' ECMAScript
proposal, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FProxy">Proxy</a>, which is characteristically circuitous and
counterintuitive. It can be <a href="http://stackoverflow.com/questions/10665892/enable-harmony-proxies-in-nodejs">turned on in V8</a> (and thus in Node), but
you'd be pretty far out on a limb to use it.</p>

<h2>Finally</h2>

<p>JavaScript was designed in a hurry, and it wasn't designed
to build large, long-lived, maintainable applications. The fact that
people are using it to do so is a testament to the ingenuity of
serious JavaScript users, and their insight that what JavaScript
<em>does</em> offer makes the failings tolerable.</p>

<p>They are significant failings, though. I've yet to hear anyone
convincingly argue that JavaScript's version of OOP offers anything in
addition to or distinction from more traditional versions; it's a kind
of Heisenbergian OOP, which breaks down as soon as you stop pretending
it's there. Similarly, I'm not convinced that the changes being made
(and proposed) are the right ones. They make the language seem more
complex -- and this is a language whose simplicity is its virtue.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mod Lang]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/05/11/mod-lang/"/>
    <updated>2013-05-11T15:43:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/05/11/mod-lang</id>
    <content type="html"><![CDATA[<p>It occurred to me this week that CoffeeScript is Javascript <strong>with
modern syntax</strong>. The thought appeared unprompted, and I'm not writing here to
argue that it's right or wrong; more that the <em>thought itself</em> gave me
pause for thought.</p>

<p>It made me realise that somewhere in my programming brain I was
differentiating between 'old world' and 'new world' syntactic
features, and the more I thought, the more interesting the thought
was.</p>

<p>So the reason I <em>am</em> writing here is to try to examine what it was
about CoffeeScript that prompted the thought, by presenting some
syntactic features that, to me, feel 'modern'. I'll also try to explain why
I think each feature belongs in a modern language.</p>

<h2>1. Stabby Lambdas</h2>

<p>The obvious number 1. CoffeeScript's lambda syntax uses the form
<code>(arguments) -&gt; body</code>. The style is probably derived from
<a href="http://www.haskell.org/haskellwiki/Anonymous_function">Haskell</a>;
<a href="http://www.erlang.org/doc/getting_started/seq_prog.html#id61265">Erlang</a>
also uses it, and it's more recently been adopted by
<a href="http://www.scala-lang.org/node/133">Scala</a>,
<a href="http://msdn.microsoft.com/en-us/library/bb397687.aspx">C#</a> and (in a
slightly backwards form)
<a href="http://pragdave.blogs.pragprog.com/pragdave/2008/05/new-lambda-synt.html">Ruby</a>.</p>

<p>What this says about language evolution is obvious, I think:
programmers want to use anonymous functions. They want to create them
quickly and easily, with a meaningful and noise-free syntax. I'd
suggest that this is evidence of the current popularity of functional
programming style, which is probably a result of the emerging
necessity to program for concurrency. I'd also venture that most
programmers using this style are interested less in concurrency
(at the hardware level) than in a convenient syntax for working
with event-driven systems (as well as a language-level
<a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy pattern</a>).</p>

<h2>2. Noise Reduction</h2>

<p>CoffeeScript makes parentheses optional in many cases (as does Ruby);
it also, in certain cases, makes braces for declaring object literals optional; commas
separating object key-value pairs and array elements can be replaced
with newlines; semicolons as line delimiters are not used; comparison and
logical operators can in many cases be replaced with equivalent
English words (<code>===</code> with <code>is</code>, <code>!==</code> with <code>isnt</code>, <code>&amp;&amp;</code> with <code>and</code>,
<code>||</code> with <code>or</code>, etc.).</p>

<p>To the same effect, CoffeeScript, like Ruby, offers flexibility in
conditional expressions, so that <code>unless</code> can be used in place of <code>if
not</code>, and any conditional operator can be used postfix, allowing
<em>bon mots</em> like <code>return unless x is 5</code>.</p>

<p>This makes the language <em>easy to read</em>. It reads fluently,
uninterrupted by messy, alienating punctuation. Sometimes this visual
clarity is bought at the expense of semantic clarity, though, and the
CoffeeScript compiler <a href="http://jameswilliams.be/blog/entry/202">can</a>
<a href="http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/">bite</a>
<a href="http://tapestryjava.blogspot.co.uk/2012/08/coffeescript-cautions.html">you</a>
if you're too <em>laissez-faire</em>. Also, how to 'phrase' your code becomes
an additional, and possibly unwelcome, decision. Rubyists have long
faced these issues, and adherence to the language's
<a href="http://stackoverflow.com/questions/613985/common-ruby-idioms">idioms</a>
is now nearly as important as correct syntax.</p>

<p>The movement to greater flexibility and fewer sigils seems to have met
with more approval than hostility, though, and I'd argue that a
driving reason for this is that less noisy, more malleable syntax
<strong>enables the creation of domain-specific languages</strong>. Rails famously
leverages Ruby's syntax to create what amounts to a declarative
language to describe things like entity relationships; other
frameworks have tried to follow suit and been frustrated by their host
language's lack of flexibility. I won't name names.</p>

<h2>3. Expressiveness through Expressions</h2>

<p>In CoffeeScript, As in
<a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_expressions.html">Ruby</a>, <a href="http://twitter.github.io/scala_school/basics.html#expressions">Scala</a>, <a href="http://ocaml.org/tutorials/structure_of_ocaml_programs.html">OCaml</a>, <a href="http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Expressions">Haskell</a> and <a href="http://en.wikipedia.org/wiki/S-expression">Lisp</a>, (almost)
<strong>everything is an expression</strong>. In simple terms, this means that
<em>every language construct returns a value</em>. An important consequence of
this is <em>implicit returns</em>: because every construct must return a
value, all functions must return a value, whether <code>return</code> is called
explicitly or not. By default, a function returns the value of the
last evaluated expression. This, again, makes for a very concise and
expressive syntax, which feels like a function just <em>is</em> its evaluated
body:</p>

<p><code>coffeescript
square = (x) -&gt; x * x
</code></p>

<p>This applies to conditionals too:</p>

<p><code>coffeescript
x = if true
  5
</code></p>

<p>(Note that this is not 'idiomatic' CoffeeScript.)</p>

<h2>4. Coalescence</h2>

<p>Like Scheme, <a href="http://eddiema.ca/2010/07/07/the-null-coalescing-operator-c-ruby-js-python/">C#, Ruby, Python and JavaScript</a>, CoffeeScript uses
<em>coalescing operators</em>. To JavaScript's coalescing <code>||</code> and <code>||=</code>,
CoffeeScript adds a coalescing existential operator, <code>?</code> and <code>?=</code>. This is
particularly useful in combination with the 'everything is an
expression' behaviour described above:</p>

<p><code>coffeescript
x = (y if y &gt; 5) or z
</code></p>

<p>It can also be used for simple memoization:</p>

<p><code>coffeescript
x = null
x ?= -&gt; (i for i in [1..20])
</code></p>

<p>And even to conditionally call a function:</p>

<p><code>coffeescript
f = (callback) -&gt; callback?()
</code></p>

<h2>Modern?</h2>

<p>You may have noticed that most of the languages I've mentioned above
are some distance from 'modern';
<a href="http://en.wikipedia.org/wiki/Scala_(programming_language#History">Scala (released 2003)</a>
has the best claim. The others range from early adulthood
(<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language#History">Ruby, mid-1990s</a>)
to spry seniority
(<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language#History">Lisp, late 1950s</a>). Why
do aspects of their syntaxes, then, seem to contribute to a sense of
modernity in language design?</p>

<p>I think this is quite simple: they don't look, or act, too much like
C.</p>

<p>C is a beautiful language, which does what it's designed for very
well: it
<a href="http://en.wikipedia.org/wiki/Von_Neumann_programming_languages">interacts with von Neumann-architecture machines</a>
at a level appreciably higher than assembly language, whilst being
highly performant, small, well-specified, and clear. But it became so
popular that the languages that followed it were pretty much
<em>required</em> to cargo-cult its syntax. What is Java but a traduction of
Smalltalk with C-like syntax bolted on? What is JavaScript but a
traduction of Scheme with Java-like syntax bolted on
(<a href="http://www.quirksmode.org/js/intro.html">by mandate</a>, in this case)?</p>

<p>As a result of C's (and its successors') popularity, alternative
languages like Lisp and Smalltalk rather faded into the background;
their practical elements were absorbed, but their syntaxes were
repressed. One could argue that Perl brought some of their syntactic
ideas closer to the mainstream -- I don't know enough Perl to have an
opinion. But once you've written Ruby or Python or CoffeeScript,
all of them strongly influenced by more <em>humanist</em> languages like the
aforementioned, it's hard to justify another set of braces, another
check for <code>null</code>, another <code>for i = 0;</code>. And there you are. Old world:
C. New world: not C.</p>

<h2>Sundries</h2>

<p>The above is a small selection of things I want from a 'modern'
language. Others might be (not in strict order):</p>

<ul>
<li><strong>Docstrings</strong>. As an Emacs user, I'm a total convert to the idea
that a language should facilitate
<a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Basics.html">self-documenting programs</a>. <a href="http://ashkenas.com/literate-coffeescript/">Literate CoffeeScript</a>
is a welcome move, but I miss being able to describe method
parameters and return values in a defined way. The Emacs Lisp
compiler complains if you don't document a function, mentioning the
params in order; this should be the norm.</li>
<li><a href="http://en.wikipedia.org/wiki/List_comprehension">Comprehensions</a>
are a very handy construct. I wish CoffeeScript would introduce
<a href="https://github.com/jashkenas/coffee-script/issues/467">object comprehensions</a>,
though.</li>
<li><strong>Keyword
arguments</strong>. <a href="http://docs.python.org/release/1.5.1p1/tut/keywordArgs.html">Python can do it</a>,
<a href="http://brainspec.com/blog/2012/10/08/keyword-arguments-ruby-2-0/">Ruby is on board</a>,
and you can
<a href="http://blog.carbonfive.com/2011/09/28/destructuring-assignment-in-coffeescript/">kind of fake it in CoffeeScript</a>,
using destructuring assignment. The king, of course, is Smalltalk,
with its
<a href="http://www.jmcsweeney.co.uk/computing/m206/messages.php">selectors</a>
-- effectively polymorphic method signatures enhanced by keyword
arguments. In Smalltalk, the selector <code>setRed:Green:AndBlue:</code> points
to a different method than <code>setRed:</code> or <code>setRed:AndGreen:</code>. Ruby
2.0's syntax strikes a nice balance, allowing arbitrary arguments in
addition to keyworded ones.</li>
</ul>


<h2>Finally</h2>

<p>Again, I'm not arguing what a 'modern' language <em>should</em> look like so
much as observing my own prejudice; also, I'm well aware that there
are horses for courses, and new(ish) languages like
<a href="http://code.google.com/p/go/">Go</a> and
<a href="http://www.rust-lang.org">Rust</a> are intended for different purposes
than Ruby or CoffeeScript.</p>

<p>I think it's all to play for at the moment; and I think it'll be a
shame if yet another C-like language wins. My money <em>was</em> on Scala as
a general purpose application developers' language, but I fear it's
getting a bit
<a href="http://www.joelonsoftware.com/articles/fog0000000018.html">astronautical</a>. JavaScript
is highly optimised, and has a (reasonably)
<a href="https://github.com/melor/node-posix">POSIX compliant host environment</a>
-- can we now consider using it for systems programming? And Ruby
seems to be becoming the
<a href="http://saviorodrigues.wordpress.com/2011/01/28/rethinking-rubys-role-in-the-cloud/">language of the Cloud</a>. Perhaps
we are doomed to, or blessed with, a pluralistic future.</p>
]]></content>
  </entry>
  
</feed>
