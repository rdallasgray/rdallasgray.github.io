<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Automatic Coding]]></title>
  <link href="http://rdallasgray.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rdallasgray.github.io/"/>
  <updated>2013-09-30T21:04:54+01:00</updated>
  <id>http://rdallasgray.github.io/</id>
  <author>
    <name><![CDATA[Robert Dallas Gray]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building a (fairly) sane dev environment in Windows]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/09/28/building-a-fairly-sane-dev-environment-in-windows/"/>
    <updated>2013-09-28T19:42:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/09/28/building-a-fairly-sane-dev-environment-in-windows</id>
    <content type="html"><![CDATA[<p>I recently left a job that mandated Windows as a development
environment. Well, that's not strictly true -- they were happy enough
for me to use Linux in a VM, but that was ultimately more trouble than
it was worth.</p>

<p>I've had to dip into Windows before (having worked a job where the
server-side code was .Net), but I've never had to use it as a primary
dev environment. Long story short: it is <em>extremely</em> painful to use
Windows for modern web development, or any kind of development which
is not explicitly <em>for</em> Windows.</p>

<p>Here is a statement of the main problems, and the measures which can
get you at least close to a solution.</p>

<h2>Git</h2>

<p>An odd one to start with perhaps, but it has a significant impact on
the rest of the setup. There are two ways you can get a usable Git
setup working on Windows: one is to use
<a href="http://www.cygwin.com">Cygwin</a>, of which more below, and one is
<a href="http://msysgit.github.io">Git for Windows</a>, otherwise known as
MSYS-Git. You can download a lightweight version of
MSYS-Git as <a href="http://git-scm.com/downloads">Git Bash</a> -- which, you
shouldn't be surprised to hear, comes with an implementation of Bash
-- but I'm going to advise getting the
<a href="http://code.google.com/p/msysgit/downloads/list?q=net+installer">full installer</a>. It
should become clear why.</p>

<p>MSYS-Git is quite slow; apparently the version that you can use with
Cygwin is faster, but Cygwin was too much of an overhead for my purposes.</p>

<h2>The command line</h2>

<p>Where to begin. The Windows command line is a  disaster, unless
all you need to do is change directories and open files. No grep. No
vi. No sed. The knock-on effects, on editors and other tools which rely
on these utilities, are not fun. I'd been recommended
<a href="http://code.google.com/p/clink/">clink</a>, which offers Bash-like
completion, but it's still ... the Windows command line.</p>

<p>The options, if you want Bash or something like it, are
<a href="http://www.cygwin.com">Cygwin</a>, effectively a complete replacement
for the Windows command system,
<a href="https://github.com/bmatzelle/gow/wiki">GoW (Gnu on Windows)</a>, a
lighter-weight port of a set of Gnu utilities, or
<a href="http://www.mingw.org/wiki/MSYS">MSYS</a>, a package similar to GoW,
intended for compiling Gnu utilities on Windows. An outside choice is
<a href="http://www.emacswiki.org/emacs/CategoryEshell">Eshell</a> if you're an
Emacs user; I tried it, but found it didn't fit well with my workflow.</p>

<p>Cygwin is a very comprehensive solution: it presumes you're basically
going to <em>exist</em> within it, which really didn't work for me. GoW was
nice, but didn't play well with the Git-integrated Bash (see above),
and neither did a separate install of MSYS. For these reasons, I
suggest installing the complete MSYS-Git environment I mentioned
above: you get Git, Bash and a decent subset of the Gnu utilities, all well-integrated.</p>

<h2>A terminal emulator</h2>

<p>That this is not a solved problem should give you some idea of The
State of Things. There are two contenders, neither of which really represents an
resounding victory:
<a href="http://code.google.com/p/conemu-maximus5/">ConEmu</a> and
<a href="http://sourceforge.net/projects/console/files/">Console2</a>. (Incidentally,
are you noticing how much of this stuff is on Google Code? And
<em>SourceForge</em> for heaven's sake? The mind boggles). ConEmu is highly
configurable. I do not need my terminal emulator to be highly
configurable. Console2 is marginally easier to use, but pug ugly. I
went for Console2.</p>

<h2>Package management</h2>

<p>The only real game in town here is
<a href="http://chocolatey.org">Chocolatey</a>. Like most community projects in
the Windows world, it's undermaintained and generally a bit thin, but at least
it's there. (And no disrespect to the maintainers here: it's numbers
I'm complaining about, not individual effort). Installs largely work;
uninstalls or upgrades often don't. But until
<a href="https://github.com/nddrylliog/winbrew">Winbrew</a> is reliable, there we
are. I managed to get <a href="http://chocolatey.org/packages/ack">ack</a>
installed via Chocolatey, so two cheers for it, at least; all the
packages mentioned above are available too.</p>

<h2>Runtime/language version managers</h2>

<p>I'm talking about the likes of
<a href="https://github.com/creationix/nvm">nvm</a> and
<a href="https://github.com/postmodern/chruby">chruby</a> here. I used
<a href="https://github.com/marcelklehr/nodist">Nodist</a> (because it was
available on Chocolatey and <a href="https://github.com/hakobera/nvmw">nvmw</a>
wasn't); there's also <a href="https://github.com/vertiginous/pik">pik</a> for
Ruby, but I couldn't get it working.</p>

<h2>Type</h2>

<p>Call me frivolous, but I have a background in typography and I <em>cannot
stand</em> the look of type on Windows. The fault lies with the
anti-aliasing, which only works in the vertical plane; type looks
spindly and horrible, no matter how you set it up. If you're used to
modern-looking type, as rendered on OS X or Ubuntu, and you have any
sort of sensitivity to these things, you just can't live with it.</p>

<p>It's not a total solution, but
<a href="https://code.google.com/p/mactype/">MacType</a> saved me clawing my eyes
out, at least.</p>

<h2>In summary</h2>

<p>Attempting web development on Windows feels like being thrown back in
time five years or so. I've touched on the main pain points, but I
can't even remember how many, many times I had to ransack Stack
Overflow to find out why such-and-such a gem wouldn't work properly,
or dig about in the awful Registry. How many times I restarted the
machine to be told that Windows had decided to install 127
updates. How long and often I watched the spinny blue circle while a bleedin'
<em>Explorer window</em> opened. Ubuntu, <em>in a VM</em>, was considerably faster
and more usable in every way.</p>

<p>The larger problem is that the whole experience of working on Windows
is so rotten that <em>nobody wants to fix this stuff</em>. Plenty of GitHub
issues I followed, on large, respectable repos, were
unresolved. 'Windows,' said the maintainers. Won't fix. Closed.</p>

<p>I really can't blame them, and similarly, I can see why the
whole open-source movement is so backward on the Windows platform;
hardly anyone's there, and community is what keeps all this going.
I hope, for the sake of the people who have to use it, that it gets
better. I won't be hanging around to see, though.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some technical podcasts I listen to]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/09/27/some-technical-podcasts-i-listen-to/"/>
    <updated>2013-09-27T20:57:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/09/27/some-technical-podcasts-i-listen-to</id>
    <content type="html"><![CDATA[<p>Been a while. Here's a short one on some of the stuff I listen to when
I have the time. It's intended primarily to solicit responses of the
'You like that? Then you'll like this!' variety -- I need more
material.</p>

<p>So, top five.</p>

<h2>Ruby Rogues</h2>

<p><a href="http://rubyrogues.com">link</a></p>

<p>An indisputable number one. Doesn't matter whether you're a Rubyist --
you'll get something from this. It's very well produced, the regulars
are well-practised, and the guests are frequently stellar (Kent Beck,
e.g.). Despite (or perhaps because of) the Ruby focus, the topics tend
to be relevant to software engineering in general, especially the reading list
episodes: Patterns of Application Architecture, Smalltalk Best
Practice Patterns, Growing Object Oriented Software ... it's the
canon, not just the Ruby stuff. Highly recommended.</p>

<h2>The Changelog</h2>

<p><a href="http://thechangelog.com">link</a></p>

<p>An overview of what's happening in open source. Very on the
pulse. Great guests, good production values and educated hosts
(although, in the nicest possible way, Adam Stacoviak would benefit
the show by doing more listening and less talking).</p>

<h2>Javascript Jabber</h2>

<p><a href="http://javascriptjabber.com">link</a></p>

<p>I'm paying less attention to Javascript these days, but I still
subscribe to and enjoy this podcast. Same stable as Ruby Rogues, and
same presenter (the very personable Charles Max Wood); similarly high
production values, too. Good guests and high-level chat.</p>

<h2>Mostly Erlang</h2>

<p><a href="http://mostlyerlang.com">link</a></p>

<p>It's interesting to get a bit out of your comfort zone. Erlang people
talk about different stuff. The show is patterned after the Ruby
Rogues/Javascript Jabber format, but the nature of the community is so
different that it's not really comparable; production values are
lower, but the guests, and the general tone, are much more oriented
toward serious systems engineering, which makes a refreshing listen,
for me.</p>

<h2>Pragmatic Podcasts</h2>

<p><a href="http://pragprog.com/podcasts">link</a></p>

<p>Somewhat few and far between (it's hard to tell if they're even still
going), these are what you'd expect from the PragProg stable: serious,
somewhat conservative, but very valuable. At their best they afford a
very high-level view of the practice of software development.</p>

<p>Honourable mentions: <a href="http://nodeup.com">NodeUp</a>, <a href="http://episodes.gitminutes.com">Git Minutes</a>, <a href="http://foodfightshow.org">Food Fight</a>.</p>

<p>Don't even talk to me about the Dev Show.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's wrong with JavaScript]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/06/09/whats-wrong-with-javascript/"/>
    <updated>2013-06-09T14:11:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/06/09/whats-wrong-with-javascript</id>
    <content type="html"><![CDATA[<p><em>(Updated 2013-06-10 with some corrections and fine-tunings)</em></p>

<p>So from my <a href="/blog/2013/05/11/mod-lang/">last post</a> you might guess I'm
an advocate for JavaScript. Well, I have more time for the language
than many Rubyists seem to: it has a nicely compact API and, once
you've learned to avoid the potholes, it's an easy language to get
things done in. CoffeeScript makes it considerably less painful to
read and write, and the Node ecosystem is generating some very useful
toolsets and ways of working.</p>

<p>There are, though, some significant pain-points involved in writing
non-trivial programs in JavaScript. Some of them are well-covered in
the literature already, but there are some that seem not to be. I'm
interested to gauge the extent to which others have come up against some
of these, so here's my take on what's <em>really</em> wrong with JavaScript.</p>

<h2>The obvious stuff</h2>

<p>I'm not going to dwell on any of this, because it's <a href="http://javascript.crockford.com/survey.html">well-trodden territory</a>,
but to get it out of the way: the scoping is wacky (and the <code>var</code> trap
is a disaster); the comparison operators (<code>==</code> vs <code>===</code>) are a kludge;
and the treatment of the <code>this</code> keyword is tiresome. There are many
more dark corners (see, for instance, <a href="http://www.youtube.com/watch?v=kXEgk1Hdze0">Gary Bernhardt's WAT</a>), but all
of these issues can be worked around more or less easily (and in fact
CoffeeScript largely does so). There are other issues with the
language that I'd argue are harder to deal with -- in some cases,
practically impossible.</p>

<h2>What is an object?</h2>

<p>So, famously, JavaScript is not a class-based language. It uses
prototypal inheritance. This is a somewhat simpler type of
object-oriented language design, whereby object instances inherit both data and
behaviour from other object instances. It can work quite well (it's a
very memory-efficient system if used properly), and it can to some
extent be used to mimic class-based inheritance if that's what you
want. The problem with JavaScript, though, is what it uses for
'objects'.</p>

<p>In JavaScript, an 'object' is effectively just a key--value structure. It is what
in other languages is called a hash, a map or a dictionary. It looks like this:</p>

<p>```javascript
var obj = {</p>

<pre><code>foo: "I'm a property!",
bar: function() {
    return "And I'm a method!"
},
baz: function() {
    return this.bar();
}
</code></pre>

<p>}
```</p>

<p>We could either use this object as-is, in which case it's what in a
class-based language we'd call a Singleton, or we can use it as the
prototype for another object instance (there are several ways to
accomplish this -- they're covered elsewhere, so I won't expand).</p>

<p>As you can see, there's no distinction between a 'method' (a member of
the object which is a function) and a 'property'. Everything is just a
value indexed on a key. Nice and simple, but take a CoffeeScript
instance method like this one:</p>

<p><code>coffeescript
thing: -&gt;
  @thing ?= new Thing
</code></p>

<p>This looks pretty and idiomatic: it's an accessor method which
assigns <code>@thing</code> if it doesn't already exist, then returns it.
See the problem?</p>

<p>CoffeeScript's syntax is helping to hide the fact that we've bound the
instance variable to the same key as the method (<code>this.thing</code>). I hope
this seems obvious to you, and that you're wondering how anyone could
be so stupid as to do such a thing. I am here to tell you that this is
something that a busy developer will do (especially one familiar with
Ruby), and that it will then manifest a very subtle bug which does not
immediately show up in unit tests. I will leave you to speculate as to
how I can be so sure about this.</p>

<p>Now, sure, we could be sensible and create <code>setThing</code> and <code>getThing</code>
methods, but, you know, we're not writing Java. We're in a highly
dynamic language. We want nice things. Or, we could create setters and
getters using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/get">new ES5 syntax</a>
-- but that's not available everywhere (pre-IE9, for instance), and, I
would argue, is too unwieldy to apply as a rule.</p>

<p>So what we're left with is doing something like:</p>

<p><code>coffeescript
thing: -&gt;
  @_thing ?= new Thing
</code></p>

<p>Which is ... irritating. But if we want this kind of method syntax,
that's what we have to do, and we have to be vigilant that we don't
introduce mistakes like the above, because no lint tool will catch them.</p>

<p>It's tempting to presume that this is a 'feature' of prototypal
inheritance; it's not. The two next best-known prototypal languages,
<a href="http://selflanguage.org/_static/tutorial/Language/ObjectsAndSlots/ObjectsAndSlots.html">Self</a> and <a href="http://www.lua.org/pil/16.html#ObjectSec">Lua</a>, distinguish properties and methods just fine.</p>

<h2>Everything is an object</h2>

<p>And that's a good thing, right?</p>

<p>Well, first, it's not really true of JavaScript: you need to <a href="http://blogs.adobe.com/webplatform/2012/08/27/javascript-types/">'box'</a>
primitives like numbers to get them to behave like objects, but fair
enough, many languages do something similar. Second, and more
importantly, see above as regards what objects in JavaScript <em>actually
are</em>. What we're really saying is 'everything is a key--value structure'. Is that
a good thing?</p>

<p>No. It isn't. Imagine another hypothetical CoffeeScript method:</p>

<p>```coffeescript
copyObject: (inputObject) ->
  copy = []
  for key, val of inputObject</p>

<pre><code>copy[key] = val
</code></pre>

<p>```</p>

<p>Spot the deliberate mistake? Busy developer has initialised <code>copy</code> to
an array rather than an object. The really bad news? <em>This method will
work almost as if it were correct</em>. We can get every key of
<code>inputObject</code> on <code>copy</code> correctly, because an array, in JavaScript, is
an object, and therefore <em>is just a key--value structure</em>. We can set
(pretty much) any key on it we like, and get it back intact. But
again, subtle bugs abound; arrays are not intended to be used like
this, and things will go wrong if, for example, you start trying to
iterate over <code>copy</code>'s properties, expecting it to be a 'real' object.</p>

<p>Ouch.</p>

<h2>Nothing is an object</h2>

<p>Try this, in a CoffeeScript class:</p>

<p>```coffeescript
bindClick: ->
  $("#clickable").on "click", @onClick</p>

<p>respondToClick: ->
  window.alert "clicked!"</p>

<p>onClick: ->
  @respondToClick()
```</p>

<p>So presuming <code>bindClick</code> has been called, what happens when we click
on <code>"#clickable"</code>?</p>

<p><code>respondtoClick</code> will never be called, and you'll almost certainly get
an exception. Remember, there are no methods in Javascript, only
functions. We bound the function <code>this.onClick</code> to the click event;
that function has no idea that it's also a method. Why should a value
in a key--value structure know which structure it belongs to? In the
context of the function <code>this.onClick</code>, <code>this</code> is the function itself
or, sometimes, the <code>window</code> object. Neither of these has a
<code>respondToClick</code> method, so we get an exception.</p>

<p>In short, we can call any function in scope, from anywhere, regardless of
whether it's part of an 'object'; and attaching a function to an object as
a method only binds <code>this</code> correctly <em>when the function is called in
the context of its parent object</em>.</p>

<p>The correct way to do the above is of course:</p>

<p><code>coffeescript
bindClick: -&gt;
  $("#clickable").on "click", =&gt; @respondToClick()
</code></p>

<p>We pass an anonymous function to <code>.on</code>, explicitly binding <code>this</code> to
our current context using CoffeeScript's <code>=&gt;</code> operator.</p>

<h2>_missing</h2>

<p>All of the above can be worked around or avoided; at
present, one very important thing can't be. JavaScript has no
equivalent to <a href="http://ruby-doc.org/core-2.0/BasicObject.html#method-i-method_missing">Ruby's <code>method_missing</code></a>, <a href="http://c2.com/cgi/wiki?DoesNotUnderstand">Smalltalk's
<code>doesNotUnderstand</code></a>, <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html">Objective-C's <code>forwardInvocation</code></a>, <a href="http://php.net/manual/en/language.oop5.overloading.php">PHP's <code>__call</code></a>,
etcetera. You can't catch a call to an undefined method in JavaScript
and then do something with it. This is, again, to do with the fact
that there's nothing to distinguish 'properties' from 'methods' in
JavaScript; plenty of 'properties' won't be callable as functions, but
that doesn't necessarily mean they <em>should be</em>.</p>

<p>It's important to be able to do this in traditional object-oriented
design; we need it to do proper <a href="http://en.wikipedia.org/wiki/Delegation_(programming">delegation</a>, for example. It's also a
tremendously convenient feature if you want to do metaprogramming
(e.g. adding properties or methods to an object dynamically at
runtime). There are two ways to sort-of do it right now: one is
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/noSuchMethod">Mozilla's <code>__noSuchMethod__</code></a>, which is only supported in SpiderMonkey
and likely to be deprecated; the other is the 'official' ECMAScript
proposal, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FProxy">Proxy</a>, which is characteristically circuitous and
counterintuitive. It can be <a href="http://stackoverflow.com/questions/10665892/enable-harmony-proxies-in-nodejs">turned on in V8</a> (and thus in Node), but
you'd be pretty far out on a limb to use it.</p>

<h2>Finally</h2>

<p>JavaScript was designed in a hurry, and it wasn't designed
to build large, long-lived, maintainable applications. The fact that
people are using it to do so is a testament to the ingenuity of
serious JavaScript users, and their insight that what JavaScript
<em>does</em> offer makes the failings tolerable.</p>

<p>They are significant failings, though. I've yet to hear anyone
convincingly argue that JavaScript's version of OOP offers anything in
addition to or distinction from more traditional versions; it's a kind
of Heisenbergian OOP, which breaks down as soon as you stop pretending
it's there. Similarly, I'm not convinced that the changes being made
(and proposed) are the right ones. They make the language seem more
complex -- and this is a language whose simplicity is its virtue.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mod Lang]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/05/11/mod-lang/"/>
    <updated>2013-05-11T15:43:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/05/11/mod-lang</id>
    <content type="html"><![CDATA[<p>It occurred to me this week that CoffeeScript is Javascript <strong>with
modern syntax</strong>. The thought appeared unprompted, and I'm not writing here to
argue that it's right or wrong; more that the <em>thought itself</em> gave me
pause for thought.</p>

<p>It made me realise that somewhere in my programming brain I was
differentiating between 'old world' and 'new world' syntactic
features, and the more I thought, the more interesting the thought
was.</p>

<p>So the reason I <em>am</em> writing here is to try to examine what it was
about CoffeeScript that prompted the thought, by presenting some
syntactic features that, to me, feel 'modern'. I'll also try to explain why
I think each feature belongs in a modern language.</p>

<h2>1. Stabby Lambdas</h2>

<p>The obvious number 1. CoffeeScript's lambda syntax uses the form
<code>(arguments) -&gt; body</code>. The style is probably derived from
<a href="http://www.haskell.org/haskellwiki/Anonymous_function">Haskell</a>;
<a href="http://www.erlang.org/doc/getting_started/seq_prog.html#id61265">Erlang</a>
also uses it, and it's more recently been adopted by
<a href="http://www.scala-lang.org/node/133">Scala</a>,
<a href="http://msdn.microsoft.com/en-us/library/bb397687.aspx">C#</a> and (in a
slightly backwards form)
<a href="http://pragdave.blogs.pragprog.com/pragdave/2008/05/new-lambda-synt.html">Ruby</a>.</p>

<p>What this says about language evolution is obvious, I think:
programmers want to use anonymous functions. They want to create them
quickly and easily, with a meaningful and noise-free syntax. I'd
suggest that this is evidence of the current popularity of functional
programming style, which is probably a result of the emerging
necessity to program for concurrency. I'd also venture that most
programmers using this style are interested less in concurrency
(at the hardware level) than in a convenient syntax for working
with event-driven systems (as well as a language-level
<a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy pattern</a>).</p>

<h2>2. Noise Reduction</h2>

<p>CoffeeScript makes parentheses optional in many cases (as does Ruby);
it also, in certain cases, makes braces for declaring object literals optional; commas
separating object key-value pairs and array elements can be replaced
with newlines; semicolons as line delimiters are not used; comparison and
logical operators can in many cases be replaced with equivalent
English words (<code>===</code> with <code>is</code>, <code>!==</code> with <code>isnt</code>, <code>&amp;&amp;</code> with <code>and</code>,
<code>||</code> with <code>or</code>, etc.).</p>

<p>To the same effect, CoffeeScript, like Ruby, offers flexibility in
conditional expressions, so that <code>unless</code> can be used in place of <code>if
not</code>, and any conditional operator can be used postfix, allowing
<em>bon mots</em> like <code>return unless x is 5</code>.</p>

<p>This makes the language <em>easy to read</em>. It reads fluently,
uninterrupted by messy, alienating punctuation. Sometimes this visual
clarity is bought at the expense of semantic clarity, though, and the
CoffeeScript compiler <a href="http://jameswilliams.be/blog/entry/202">can</a>
<a href="http://ceronman.com/2012/09/17/coffeescript-less-typing-bad-readability/">bite</a>
<a href="http://tapestryjava.blogspot.co.uk/2012/08/coffeescript-cautions.html">you</a>
if you're too <em>laissez-faire</em>. Also, how to 'phrase' your code becomes
an additional, and possibly unwelcome, decision. Rubyists have long
faced these issues, and adherence to the language's
<a href="http://stackoverflow.com/questions/613985/common-ruby-idioms">idioms</a>
is now nearly as important as correct syntax.</p>

<p>The movement to greater flexibility and fewer sigils seems to have met
with more approval than hostility, though, and I'd argue that a
driving reason for this is that less noisy, more malleable syntax
<strong>enables the creation of domain-specific languages</strong>. Rails famously
leverages Ruby's syntax to create what amounts to a declarative
language to describe things like entity relationships; other
frameworks have tried to follow suit and been frustrated by their host
language's lack of flexibility. I won't name names.</p>

<h2>3. Expressiveness through Expressions</h2>

<p>In CoffeeScript, As in
<a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_expressions.html">Ruby</a>, <a href="http://twitter.github.io/scala_school/basics.html#expressions">Scala</a>, <a href="http://ocaml.org/tutorials/structure_of_ocaml_programs.html">OCaml</a>, <a href="http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Expressions">Haskell</a> and <a href="http://en.wikipedia.org/wiki/S-expression">Lisp</a>, (almost)
<strong>everything is an expression</strong>. In simple terms, this means that
<em>every language construct returns a value</em>. An important consequence of
this is <em>implicit returns</em>: because every construct must return a
value, all functions must return a value, whether <code>return</code> is called
explicitly or not. By default, a function returns the value of the
last evaluated expression. This, again, makes for a very concise and
expressive syntax, which feels like a function just <em>is</em> its evaluated
body:</p>

<p><code>coffeescript
square = (x) -&gt; x * x
</code></p>

<p>This applies to conditionals too:</p>

<p><code>coffeescript
x = if true
  5
</code></p>

<p>(Note that this is not 'idiomatic' CoffeeScript.)</p>

<h2>4. Coalescence</h2>

<p>Like Scheme, <a href="http://eddiema.ca/2010/07/07/the-null-coalescing-operator-c-ruby-js-python/">C#, Ruby, Python and JavaScript</a>, CoffeeScript uses
<em>coalescing operators</em>. To JavaScript's coalescing <code>||</code> and <code>||=</code>,
CoffeeScript adds a coalescing existential operator, <code>?</code> and <code>?=</code>. This is
particularly useful in combination with the 'everything is an
expression' behaviour described above:</p>

<p><code>coffeescript
x = (y if y &gt; 5) or z
</code></p>

<p>It can also be used for simple memoization:</p>

<p><code>coffeescript
x = null
x ?= -&gt; (i for i in [1..20])
</code></p>

<p>And even to conditionally call a function:</p>

<p><code>coffeescript
f = (callback) -&gt; callback?()
</code></p>

<h2>Modern?</h2>

<p>You may have noticed that most of the languages I've mentioned above
are some distance from 'modern';
<a href="http://en.wikipedia.org/wiki/Scala_(programming_language#History">Scala (released 2003)</a>
has the best claim. The others range from early adulthood
(<a href="http://en.wikipedia.org/wiki/Ruby_(programming_language#History">Ruby, mid-1990s</a>)
to spry seniority
(<a href="http://en.wikipedia.org/wiki/Lisp_(programming_language#History">Lisp, late 1950s</a>). Why
do aspects of their syntaxes, then, seem to contribute to a sense of
modernity in language design?</p>

<p>I think this is quite simple: they don't look, or act, too much like
C.</p>

<p>C is a beautiful language, which does what it's designed for very
well: it
<a href="http://en.wikipedia.org/wiki/Von_Neumann_programming_languages">interacts with von Neumann-architecture machines</a>
at a level appreciably higher than assembly language, whilst being
highly performant, small, well-specified, and clear. But it became so
popular that the languages that followed it were pretty much
<em>required</em> to cargo-cult its syntax. What is Java but a traduction of
Smalltalk with C-like syntax bolted on? What is JavaScript but a
traduction of Scheme with Java-like syntax bolted on
(<a href="http://www.quirksmode.org/js/intro.html">by mandate</a>, in this case)?</p>

<p>As a result of C's (and its successors') popularity, alternative
languages like Lisp and Smalltalk rather faded into the background;
their practical elements were absorbed, but their syntaxes were
repressed. One could argue that Perl brought some of their syntactic
ideas closer to the mainstream -- I don't know enough Perl to have an
opinion. But once you've written Ruby or Python or CoffeeScript,
all of them strongly influenced by more <em>humanist</em> languages like the
aforementioned, it's hard to justify another set of braces, another
check for <code>null</code>, another <code>for i = 0;</code>. And there you are. Old world:
C. New world: not C.</p>

<h2>Sundries</h2>

<p>The above is a small selection of things I want from a 'modern'
language. Others might be (not in strict order):</p>

<ul>
<li><strong>Docstrings</strong>. As an Emacs user, I'm a total convert to the idea
that a language should facilitate
<a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Documentation-Basics.html">self-documenting programs</a>. <a href="http://ashkenas.com/literate-coffeescript/">Literate CoffeeScript</a>
is a welcome move, but I miss being able to describe method
parameters and return values in a defined way. The Emacs Lisp
compiler complains if you don't document a function, mentioning the
params in order; this should be the norm.</li>
<li><a href="http://en.wikipedia.org/wiki/List_comprehension">Comprehensions</a>
are a very handy construct. I wish CoffeeScript would introduce
<a href="https://github.com/jashkenas/coffee-script/issues/467">object comprehensions</a>,
though.</li>
<li><strong>Keyword
arguments</strong>. <a href="http://docs.python.org/release/1.5.1p1/tut/keywordArgs.html">Python can do it</a>,
<a href="http://brainspec.com/blog/2012/10/08/keyword-arguments-ruby-2-0/">Ruby is on board</a>,
and you can
<a href="http://blog.carbonfive.com/2011/09/28/destructuring-assignment-in-coffeescript/">kind of fake it in CoffeeScript</a>,
using destructuring assignment. The king, of course, is Smalltalk,
with its
<a href="http://www.jmcsweeney.co.uk/computing/m206/messages.php">selectors</a>
-- effectively polymorphic method signatures enhanced by keyword
arguments. In Smalltalk, the selector <code>setRed:Green:AndBlue:</code> points
to a different method than <code>setRed:</code> or <code>setRed:AndGreen:</code>. Ruby
2.0's syntax strikes a nice balance, allowing arbitrary arguments in
addition to keyworded ones.</li>
</ul>


<h2>Finally</h2>

<p>Again, I'm not arguing what a 'modern' language <em>should</em> look like so
much as observing my own prejudice; also, I'm well aware that there
are horses for courses, and new(ish) languages like
<a href="http://code.google.com/p/go/">Go</a> and
<a href="http://www.rust-lang.org">Rust</a> are intended for different purposes
than Ruby or CoffeeScript.</p>

<p>I think it's all to play for at the moment; and I think it'll be a
shame if yet another C-like language wins. My money <em>was</em> on Scala as
a general purpose application developers' language, but I fear it's
getting a bit
<a href="http://www.joelonsoftware.com/articles/fog0000000018.html">astronautical</a>. JavaScript
is highly optimised, and has a (reasonably)
<a href="https://github.com/melor/node-posix">POSIX compliant host environment</a>
-- can we now consider using it for systems programming? And Ruby
seems to be becoming the
<a href="http://saviorodrigues.wordpress.com/2011/01/28/rethinking-rubys-role-in-the-cloud/">language of the Cloud</a>. Perhaps
we are doomed to, or blessed with, a pluralistic future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async sequences using jQuery.Deferred]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/04/27/async-sequences-using-jquery-dot-deferred/"/>
    <updated>2013-04-27T12:18:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/04/27/async-sequences-using-jquery-dot-deferred</id>
    <content type="html"><![CDATA[<p>At work, I've been coding on a project which has to wrangle a lot of
asynchronous processes. At first, I stuck with the Node.js convention
of using callbacks accepting <code>(error, data)</code> arguments, but I found
that tended to make the code a little circuitous. As the project
in question would largely be used on the front-end, I didn't feel I
really had to stick to those conventions, so I looked into
<a href="http://api.jquery.com/category/deferred-object/">jQuery's Deferred object</a>,
and especially its use of <a href="http://api.jquery.com/promise/">promises</a>.</p>

<p>This isn't a post about promises, so I won't go too deeply into what
they are, but suffice to say they offer an alternative way to manage
asynchrony, with an arguably cleaner syntax; the <code>Deferred</code> object
also simplifies chaining asynchronous functions, and provides a way to
signal when a group of functions has completed (when their <code>deferred</code>s
have <code>resolve</code>d, in the parlance). This is
<a href="http://api.jquery.com/jQuery.when/">jQuery.when</a>.</p>

<p><code>when</code> is very useful; you pass it some functions (each of which must call
<code>Deferred.resolve</code> on completion), and it tells you when they're all
complete. Only problem is that the functions are called in
parallel. Now, as a default behaviour, this makes perfect sense: we
are talking about asynchrony after all. But in some cases, we want to
ensure that our functions execute in a particular sequence, each
function awaiting the completion of its
predecessor. <code>jQuery.Deferred</code>, so far as I was able to find out,
doesn't provide for such a use case.</p>

<p>There are of course other libraries which <em>do</em> --
<a href="https://github.com/caolan/async">Async.js</a>, for example -- but I'd
thrown in my lot with jQuery, and I was reluctant to import a
whole library for just this small and apparently simple piece of
functionality.</p>

<p>Now, at work, we're lucky enough to be using
<a href="http://coffeescript.org">CoffeeScript</a> for almost all our
Javascript-y business, and the solution to my problem turned out to be
quite a beautiful little five-liner:</p>

<p>```coffeescript
sequence = (tasks) ->
  seq = tasks<a href="">0</a>
  for task, i in tasks[1..]</p>

<pre><code>seq = do (i) -&gt; seq.then -&gt; tasks[i + 1]()
</code></pre>

<p>  seq
```</p>

<p>So, what's happening here? Well, we pass an array of tasks (functions
which implement <code>Deferred.resolve</code>, and return a <code>promise</code>) to <code>sequence</code>. Sequence then
executes the <em>first</em> task, and iterates over the rest, each time
calling <code>Deferred.then</code> on the new value of <code>seq</code>; the function passed
to <code>then</code> calls the next task, which returns a <code>promise</code>, and so
on. The sequence itself is returned; this value is in fact also a
<code>promise</code> -- the one returned by the last function in the sequence --
which allows you to act on the sequence's completion.</p>

<p>Note the use of CoffeeScript's <code>do</code> keyword, which creates an
immediately-executing function. This is necessary to preserve the
scope of the index variable in the function passed to <code>then</code>;
were we not to enclose the call to <code>then</code> in an outer function, <code>i</code>
would remain scoped to the <code>i</code> given in the loop declaration. When the
function using <code>i</code> was called, it would of course take the value of <code>i</code>
<em>at the time of being called</em>, not at the time of the function's
creation -- which value is most likely to be the value of <code>i</code> at the
end of the loop.</p>

<p>Of course, the simplicity of this code is bought at the expense of
error handling, of which there's none: you'd at least want to check
you had an array of length > 0, to avoid exceptions, and it would make
sense to avoid the iteration altogether if the array were only of
length 1. Nevertheless, I think it's a nice demonstration of both
CoffeeScript's concision and <code>$.Deferred</code>'s flexibility.</p>
]]></content>
  </entry>
  
</feed>
