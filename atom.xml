<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Automatic Coding]]></title>
  <link href="http://rdallasgray.github.io/atom.xml" rel="self"/>
  <link href="http://rdallasgray.github.io/"/>
  <updated>2013-04-27T14:48:00+01:00</updated>
  <id>http://rdallasgray.github.io/</id>
  <author>
    <name><![CDATA[Robert Dallas Gray]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Async sequences using jQuery.Deferred]]></title>
    <link href="http://rdallasgray.github.io/blog/2013/04/27/async-sequences-using-jquery-dot-deferred/"/>
    <updated>2013-04-27T12:18:00+01:00</updated>
    <id>http://rdallasgray.github.io/blog/2013/04/27/async-sequences-using-jquery-dot-deferred</id>
    <content type="html"><![CDATA[<p>At work, I&#8217;ve been coding on a project which has to wrangle a lot of
asynchronous processes. At first, I stuck with the Node.js convention
of using callbacks accepting <code>(error, data)</code> arguments, but I found
that tended to make the code a little circuitous. As the project
in question would largely be used on the front-end, I didn&#8217;t feel I
really had to stick to those conventions, so I looked into
<a href="http://api.jquery.com/category/deferred-object/">jQuery&#8217;s Deferred object</a>,
and especially its use of <a href="http://api.jquery.com/promise/">promises</a>.</p>

<p>This isn&#8217;t a post about promises, so I won&#8217;t go too deeply into what
they are, but suffice to say they offer an alternative way to manage
asynchrony, with an arguably cleaner syntax; the <code>Deferred</code> object
also simplifies chaining asynchronous functions, and provides a way to
signal when a group of functions has completed (when their <code>deferred</code>s
have <code>resolve</code>d, in the parlance). This is
<a href="http://api.jquery.com/jQuery.when/">jQuery.when</a>.</p>

<p><code>when</code> is very useful; you pass it some functions (each of which must call
<code>Deferred.resolve</code> on completion), and it tells you when they&#8217;re all
complete. Only problem is that the functions are called in
parallel. Now, as a default behaviour, this makes perfect sense: we
are talking about asynchrony after all. But in some cases, we want to
ensure that our functions execute in a particular sequence, each
function awaiting the completion of its
predecessor. <code>jQuery.Deferred</code>, so far as I was able to find out,
doesn&#8217;t provide for such a use case.</p>

<p>There are of course other libraries which <em>do</em> &#8211;
<a href="https://github.com/caolan/async">Async.js</a>, for example &#8211; but I&#8217;d
thrown in my lot with jQuery, and I was reluctant to import a
whole library for just this small and apparently simple piece of
functionality.</p>

<p>Now, at work, we&#8217;re lucky enough to be using
<a href="http://coffeescript.org">CoffeeScript</a> for almost all our
Javascript-y business, and the solution to my problem turned out to be
quite a beautiful little five-liner:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='coffeescript'><span class='line'><span class="nv">sequence = </span><span class="nf">(tasks) -&gt;</span>
</span><span class='line'>  <span class="nv">seq = </span><span class="nx">tasks</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
</span><span class='line'>  <span class="k">for</span> <span class="nx">task</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">tasks</span><span class="p">[</span><span class="mi">1</span><span class="p">..]</span>
</span><span class='line'>    <span class="nv">seq = </span><span class="nx">do</span> <span class="nf">(i) -&gt;</span> <span class="nx">seq</span><span class="p">.</span><span class="nx">then</span> <span class="nf">-&gt;</span> <span class="nx">tasks</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]()</span>
</span><span class='line'>  <span class="nx">seq</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, what&#8217;s happening here? Well, we pass an array of tasks (functions
which implement <code>Deferred.resolve</code>, and return a <code>promise</code>) to <code>sequence</code>. Sequence then
executes the <em>first</em> task, and iterates over the rest, each time
calling <code>Deferred.then</code> on the new value of <code>seq</code>; the function passed
to <code>then</code> calls the next task, which returns a <code>promise</code>, and so
on. The sequence itself is returned; this value is in fact also a
<code>promise</code> &#8211; the one returned by the last function in the sequence &#8211;
which allows you to act on the sequence&#8217;s completion.</p>

<p>Note the use of CoffeeScript&#8217;s <code>do</code> keyword, which creates an
immediately-executing function. This is necessary to preserve the
scope of the index variable in the function passed to <code>then</code>;
were we not to enclose the call to <code>then</code> in an outer function, <code>i</code>
would remain scoped to the <code>i</code> given in the loop declaration. When the
function using <code>i</code> was called, it would of course take the value of <code>i</code>
<em>at the time of being called</em>, not at the time of the function&#8217;s
creation &#8211; which value is most likely to be the value of <code>i</code> at the
end of the loop.</p>

<p>Of course, the simplicity of this code is bought at the expense of
error handling, of which there&#8217;s none: you&#8217;d at least want to check
you had an array of length > 0, to avoid exceptions, and it would make
sense to avoid the iteration altogether if the array were only of
length 1. Nevertheless, I think it&#8217;s a nice demonstration of both
CoffeeScript&#8217;s concision and <code>$.Deferred</code>&#8217;s flexibility.</p>
]]></content>
  </entry>
  
</feed>
